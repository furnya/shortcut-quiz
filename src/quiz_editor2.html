<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Shortcut Quiz</title>
    <style>
      body {
        font-family:
          -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell,
          'Open Sans', 'Helvetica Neue', sans-serif;
        color: var(--vscode-foreground);
        background-color: var(--vscode-editor-background);
        padding: 20px;
        max-width: 800px;
        margin: 0 auto;
      }

      .question {
        font-size: 1.2em;
        margin-bottom: 20px;
      }

      .keyboard-hint {
        display: flex;
        align-items: center;
        gap: 4px;
        flex-wrap: wrap;
        margin-top: 5px;
      }

      .key {
        background: var(--vscode-button-background);
        color: var(--vscode-button-foreground);
        padding: 5px 10px;
        border-radius: 4px;
        font-family: monospace;
        display: inline-block;
      }

      .answer {
        margin-top: 20px;
        padding: 15px;
        border-left: 4px solid var(--vscode-activityBarBadge-background);
        background-color: var(--vscode-editor-inactiveSelectionBackground);
      }

      button {
        background: var(--vscode-button-background);
        color: var(--vscode-button-foreground);
        border: none;
        padding: 8px 12px;
        cursor: pointer;
        margin-right: 10px;
        margin-top: 10px;
      }

      button:hover {
        background: var(--vscode-button-hoverBackground);
      }

      .progress {
        margin-bottom: 20px;
        font-size: 0.9em;
        color: var(--vscode-descriptionForeground);
      }

      .feedback {
        margin-top: 15px;
        height: 20px;
        animation: fade-in 0.3s ease-in-out forwards;
        /* opacity: 1; */
        /* transition: opacity 10s ease-in-out, transform 10s ease-in-out; */
        /* transition: opacity 10s ease-in-out; */
      }

      .feedback.incorrect {
        /* animation: fade-in 10s ease-in-out forwards; */
        animation: fadeInOut 6s ease-in-out forwards;
      }

      /* .feedback.fade-out {
        opacity: 0;
        transform: translateY(-10px);
        height: 0;
        margin-top: 0;
      } */

      @keyframes fade-in {
        from {
          opacity: 0;
          transform: translateY(-10px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      @keyframes fadeInOut {
        0% {
          opacity: 0;
          transform: translateY(-10px);
        }
        5% {
          opacity: 1;
          transform: translateY(0);
        }
        95% {
          opacity: 1;
          transform: translateY(0);
        }
        100% {
          opacity: 0;
          transform: translateY(-10px);
        }
      }

      .correct {
        color: var(--vscode-testing-iconPassed);
      }

      .incorrect {
        color: var(--vscode-testing-iconFailed);
      }

      .completion {
        text-align: center;
        margin-top: 30px;
      }
    </style>
  </head>

  <body>
    <div id="app"></div>

    <script type="module">
      import { h, render, Component } from 'https://esm.sh/preact';
      import htm from 'https://esm.sh/htm';

      const html = htm.bind(h);
      const vscode = acquireVsCodeApi();

      // Store state in vscode state storage
      // const previousState = vscode.getState() || { scores: {} };
      let keyMappings = {};

      class KeybindingQuiz extends Component {
        constructor(props) {
          super(props);
          this.state = {
            keybindings: [],
            currentIndex: 0,
            currentStep: [],
            currentSteps: [],
            showAnswer: false,
            feedback: null,
            isComplete: false,
            isFadingOut: false,
            // scores: previousState.scores,
          };
          this.feedbackTimer = null;
          this.fadeOutTimer = null;
        }

        componentDidMount() {
          window.addEventListener('message', this.handleMessage);
          document.addEventListener('keydown', this.handleKeydown);
          // vscode.postMessage({ command: 'ready' });
        }

        componentWillUnmount() {
          window.removeEventListener('message', this.handleMessage);
          document.removeEventListener('keydown', this.handleKeydown);
          if (this.feedbackTimer) {
            clearTimeout(this.feedbackTimer);
          }
          if (this.fadeOutTimer) {
            clearTimeout(this.fadeOutTimer);
          }
        }

        handleMessage = (event) => {
          const message = event.data;
          if (message.command === 'setKeybindings') {
            keyMappings = message.keyMappings || {};
            console.log('Received keybindings', message.keybindings);
            this.initializeKeybindings(message.keybindings);
          }
        };

        translateVSCodeKey = (vsCodeKey) => {
          // Convert to lowercase for case-insensitive matching
          const key = vsCodeKey.toLowerCase();
          // Return the mapped browser key or the original if no mapping exists
          return (keyMappings[key] || vsCodeKey).toLowerCase();
        };

        initializeKeybindings = (keybindings) => {
          if (!keybindings || !keybindings.length) return;

          const currentSteps = this.getStepsFromKeybindings(keybindings[0]);

          console.log('Current steps:', currentSteps);
          this.setState({
            keybindings,
            currentSteps,
            currentStep: currentSteps.map((_) => 0),
          });
        };

        getStepsFromKeybindings = (keybinding) => {
          if (!keybinding || !keybinding.keys.length) return [];

          const steps = [];
          for (const k of keybinding.keys) {
            const step = [];
            for (const keymatch of k.split(' ')) {
              // Split by + to handle key combinations
              const vsCodeKeys = keymatch.toLowerCase().split('+');
              step.push({
                key: this.translateVSCodeKey(vsCodeKeys[vsCodeKeys.length - 1]),
                modifiers: vsCodeKeys
                  .slice(0, vsCodeKeys.length - 1)
                  .map((k) => this.translateVSCodeKey(k)),
              });
              // Translate each VS Code key to browser event key
              // const browserKeys = vsCodeKeys.map((key) => {
              //   // Don't translate modifier keys, as we handle them separately
              //   if (['ctrl', 'shift', 'alt', 'meta'].includes(key)) {
              //     return key;
              //   }
              //   return this.translateVSCodeKey(key);
              // });
            }
            steps.push(step);
          }
          return steps;
        };

        handleKeydown = (event) => {
          console.log('Keydown event:', event);
          const { currentStep, currentSteps, showAnswer } = this.state;
          console.log('Current step:', currentStep);
          console.log('Current steps:', currentSteps);
          console.log('Show answer:', showAnswer);

          // If answer is already showing, don't process keypresses
          if (showAnswer) return;

          const steps = currentSteps.map((s, i) => s[currentStep[i]]);
          console.log('Steps:', steps);
          if (!steps.length) return;
          let pressedKey = event.key.toLowerCase();
          const pressedKeyCode = event.code.toLowerCase();
          if (pressedKeyCode.startsWith('Numpad')) {
            pressedKey = null;
          }
          console.debug('Pressed key, code:', pressedKey, pressedKeyCode);
          if (['control', 'shift', 'alt', 'meta'].includes(pressedKey)) {
            return;
          }
          let correctSteps = steps.map((_) => false);
          for (const [i, step] of steps.entries()) {
            const { key, modifiers } = step;

            console.debug('Expected key:', key);
            console.debug('Expected modifiers:', modifiers);

            // Check if the pressed key matches the current step
            if (
              (!modifiers.includes('ctrl') || event.ctrlKey) &&
              (!modifiers.includes('shift') || event.shiftKey) &&
              (!modifiers.includes('alt') || event.altKey) &&
              (!modifiers.includes('meta') || event.metaKey) &&
              [pressedKey, pressedKeyCode].includes(key)
            ) {
              correctSteps[i] = true;
            }
          }
          const newCurrentStep = currentStep.map((s, i) => (correctSteps[i] ? s + 1 : 0));
          if (correctSteps.some((s) => s)) {
            event.preventDefault();
            event.stopPropagation();
            if (newCurrentStep.some((s, i) => s >= currentSteps[i].length)) {
              // Correct sequence completed
              this.handleCorrectAnswer();
            } else {
              // Move to next step in the sequence
              this.setState({
                currentStep: newCurrentStep,
                feedback: { type: 'progress', text: 'Keep going...' },
              });
            }
          } else {
            if (this.feedbackTimer) {
              clearTimeout(this.feedbackTimer);
            }
            if (this.fadeOutTimer) {
              clearTimeout(this.fadeOutTimer);
            }
            // Reset on incorrect key
            this.setState({
              currentStep: newCurrentStep,
              feedback: { type: 'incorrect', text: 'Incorrect key, try again' },
              feedbackKey: this.state.feedbackKey + 1, // Increment key to force re-render
              // isFadingOut: false,
            });
          }
        };

        handleCorrectAnswer = () => {
          // const { keybindings, currentIndex, scores } = this.state;
          const { keybindings, currentIndex } = this.state;
          const current = keybindings[currentIndex];

          // Update score for this keybinding
          // const updatedScores = { ...scores };
          // updatedScores[current.command] = (updatedScores[current.command] || 0) + 1;

          this.setState({
            showAnswer: true,
            feedback: { type: 'correct', text: 'Correct! Well done.' },
            // scores: updatedScores,
          });

          // Send message to extension
          vscode.postMessage({
            command: 'keybindingAnswer',
            correct: true,
            keybindingCommand: current.command,
          });

          // Save state to vscode storage
          // vscode.setState({ scores: updatedScores });
        };

        handleShowAnswer = () => {
          const { keybindings, currentIndex, scores } = this.state;
          const current = keybindings[currentIndex];

          // Update score for this keybinding (negative)
          // const updatedScores = { ...scores };
          // updatedScores[current.command] = (updatedScores[current.command] || 0) - 1;

          this.setState({
            showAnswer: true,
            // scores: updatedScores,
          });

          // Send message to extension
          vscode.postMessage({
            command: 'keybindingAnswer',
            correct: false,
            keybindingCommand: current.command,
          });

          // Save state to vscode storage
          // vscode.setState({ scores: updatedScores });
        };

        handleNext = () => {
          const { keybindings, currentIndex } = this.state;
          const nextIndex = currentIndex + 1;

          if (nextIndex >= keybindings.length) {
            // Quiz complete
            this.setState({ isComplete: true });
            return;
          }

          const nextSteps = this.getStepsFromKeybindings(keybindings[nextIndex]);

          this.setState({
            currentIndex: nextIndex,
            currentSteps: nextSteps,
            currentStep: nextSteps.map((_) => 0),
            showAnswer: false,
            feedback: null,
          });
        };

        handleRestart = () => {
          const { keybindings } = this.state;
          const firstSteps = this.getStepsFromKeybindings(keybindings[0]);

          this.setState({
            currentIndex: 0,
            currentSteps: firstSteps,
            currentStep: firstSteps.map((_) => 0),
            showAnswer: false,
            feedback: null,
            isComplete: false,
          });
        };

        renderKeyboardHint = () => {
          const { currentSteps } = this.state;

          if (!currentSteps || currentSteps.length === 0) return null;

          return html`
            <ul>
              ${currentSteps.map(
                (s) => html`
                  <li>
                    <div class="keyboard-hint">
                      ${s.map(
                        (step, stepIndex) =>
                          html`${step.modifiers.map(
                              (key) => html`<span class="key">${key}</span>+`,
                            )}
                            <span class="key">${step.key}</span>
                            ${stepIndex < s.length - 1 ? ' then ' : ''}`,
                      )}
                    </div>
                  </li>
                `,
              )}
            </ul>
          `;
        };

        renderFeedback = () => {
          const { feedback, feedbackKey } = this.state;

          if (!feedback) return null;

          // if (feedback.type === 'incorrect') {
          //   return html`
          //     <div key=${feedbackKey} class="feedback incorrect">${feedback.text}</div>
          //   `;
          // }

          return html`
            <div key=${feedbackKey} class="feedback ${feedback.type}">${feedback.text}</div>
          `;
        };

        render() {
          const { keybindings, currentIndex, showAnswer, isComplete } = this.state;

          if (keybindings.length === 0) {
            return html`<div>Loading...</div>`;
          }

          if (isComplete) {
            return html`
              <div class="completion">
                <h2>Quiz Complete!</h2>
                <p>You've finished the keyboard shortcuts quiz.</p>
                <button onClick=${this.handleRestart}>Start Over</button>
              </div>
            `;
          }

          const current = keybindings[currentIndex];

          return html`
            <div>
              <div class="progress">Question ${currentIndex + 1}/${keybindings.length}</div>

              <div class="question">
                What is the shortcut for "${current.title}" (${current.command})?
              </div>

              ${this.renderFeedback()}
              ${!showAnswer &&
              html`<div>
                <button onClick=${this.handleShowAnswer} disabled=${showAnswer}>Show Answer</button>
              </div>`}
              ${showAnswer &&
              html`
                <div class="answer">
                  The shortcuts for "${current.title}" are ${this.renderKeyboardHint()}
                </div>

                <button onClick=${this.handleNext}>Next Question</button>
              `}
            </div>
          `;
        }
      }

      // Render the app
      render(h(KeybindingQuiz, {}), document.getElementById('app'));
    </script>
  </body>
</html>
